# Final Report

## Discussion
Our final project ended up being a little different than what we originally proposed. We have not implemented a way to recommend users recipes/foods based on their current macronutrients, opting first to create the CRUD functionalities of the Recipe table and MealPlan tables. The basic calorie counting based on the recipes is still present, as is the visualization, which changed from showing a week's worth of data to only three days for simplicity. 

Usefulness-wise, we have implemented four of the main functions of our app: creating recipes, updating them, the individual calorie requirement (a user can enter their's and compare it against what they currently have in their nutrition log) and the visualization. In our application, we failed to implement the food/recipe recommendation based on macronutrients. We ended up instead creating a summary/nutrition statistics page that calculated summary values for all macros during the day (a sum) and during the week (an average), which is where the individual calorie requirement is also.

Our schema was changed during the stage 2 revisions process, but other than the changes outlined in the "stage2_revisions.md" file, we have not changed our logical schema. The only other thing we had to do was add a Quantity variable to the Ingredients table so that we could accurately measure macronutrient information in a recipe (the quantity mattered in the math). Our data sources have not changed but expanded to include five food datasets, a recipe dataset that we had to manually go through to update food quantities to fit our app's specifications, a mock userinfo dataset filled with mock user data we created, a mock nutritionlog dataset for those users that we created, and an ingredients dataset that we made based on the recipe data we had (because of the many-to-many relationship, we had to update this manually).

In terms of our UML diagram design to our logical schema, we didn't replace or change anything from what was given in the stage2_revisions file. We did add a foreign key contraint on NutritionLog.RecipeID so that we only include valid recipes in our nutrition logs, but we stated that in our stage 2 and stage 3 files. We thought that was more suitable because a nutriton log should only have valid recipes that we have data for.

Functionality-wise, we were not able to implement the recipe/food recommendation feature like we wanted because we did not have enough time as a group to get it done. Our first priority was the project specifications, which we have implemented.

## Advanced Database Programs
Our first stored procedure, which gets a user's total nutrition on the day they ask for it and their weekly averages, is really helpful for our application. If a user wants to get a summary of their macronutrients for the day and the week, they can simply hit a button and they know pretty much everything they need to. In a calorie counter type of app such as BalanceBites, this is very helpful as users typically want some kind of record of their weekly calories and always want to see their daily calories whenever they can. 

Our transaction, which is nested inside a stored procedure, is built for two main purposes. The first is to allow a user to create a meal plan, and the second is to give some summary information about their chosen meal plan. It calculates the total calories of a meal plan, which is great for when a user wants to use a specified meal plan for the entire day, so they always know what they're putting in their bodies, and since protein is so low is most people's diets, we also show them the average protein out of all their recipes, so they have a good idea how much protein they get per recipe in their meal plan. Since that SQL query was a read, we used another read to build a more complex transaction with the correct isolation level, which gives the total number of ingredients one needs to make all the recipes in their meal plan as well as what the average number of ingredients they need per recipe. This would help a user plan out their day to make sure they have the right number of ingredients on-hand both in total (if they're extra prepared) and on average (in case they don't want to take a trip to the store today). Both of these functions give a more robust and clear picture of the purpose of the meal plans--to prepare for the day. A user can take this information and know exactly what they need and what they're putting in their bodies all in one fell swoop simply by adding a meal plan.

Our trigger works well for inserting meal plans, making it so any meal plan that is not given a name is given a name of "Untitled Meal Plan" and is set to private. In many other calorie counter apps, they do this to maintain privacy and ensure that one can easily access all their meal plans simply by looking at their names. This enriches the experience by making meal plans work for the user and not only for the system.

Our constraints complement our application by making sure everything in the database makes sense. For example, as mentioned above, a foreign key constraint on NutritionLog.RecipeID is necessary so that we can actually calculate macronutrient information for a user. The other foreign key constraints are made in the same way as taught in class and are designed so that things like Recipes.UserID are allowed to be NULL (because a recipe can be made by us, the developers, or not be attributed to anyone) while other things, like MealPlan.UserID are not allowed to be NULL and must be deleted on cascade in case a user deletes their meal plan. The meal plans, for example, vary from one user to another and it wouldn't make sense for me to be able to follow someone else's meal plan (unless I wanted to of course, which is why the meal plans have a "Public" variable). We also made Ingredients.Quantity not allowed to be NULL because it makes no sense to have a NULL ingredient quantity and allowing it would break the math.

## Technical Challenges

- **Jake:** The hardest parts of the project were the planning and setup. Distributing work among the group was hard to keep things fair, especially when we didn't know the scope of everything. For example, we had no idea at the beginning that we would need to go through the recipe data and change it to fit our application. In this way, it's important to either pick flexible datasets or build the database around the dataset, and not the other way around. Setup was very hard as well as it took us a while to get started on stage 4 because each of us had a different setup issue (for example I couldn't install node properly the first time, which crippled how much I could help). Regarding this, we learned that setting up everything early (and planning early too) were the major keys to success, regardless of how much work needed to be done.
  
- **Chi:** Incorporating the datasets into their proper tables was the hardest task for me. When we split up the work for stage 3, I was tasked with inserting the data into the database, but our recipe data was not compliant with the logical schema of our application. Because of this, I had to manually go through each recipe and fix them (for example, one ingredient's unit of measurement was listed as "spicy", which doesn't even make sense). The food datasets we had all contained macronutrient information per 100 grams of each food, so after going through each recipe's unit of measurement, I had to normalize them all to 100 gram increments, which took awhile. On top of this, because of the many-to-many relationship from Foods to Recipes, I had to enter information into the ingredients table based on the recipes we already had so that a user could query one of our given recipes to find its macros. 

- **Jason:** For me, the biggest issue was making sure the application kept track of which user was currently logged in on every page. The main problem with this was getting the cookie session created properly to track a user. This took a lot of time and effort because I had to research and understand the process of cookies. I learned that a big part of an application is the user, and underestimating anything even as small as tracking the user can result in a huge time-sink. Another problem I had was with creating new users on the frontend, but this was largely due to me forgetting to convert something into a string in SQL, which resulted in the command failing. Essentially, type-handling from the frontend was another issue I didn't expect to see.

- **Dan:** My biggest issue with the project, technically-speaking, was the visualization. In the stage 4 process, I chose to work on the visualization since the backend was largely done when I started. The issues with this wasn't actually the visualization itself but rather linking the front and the backend for it. Because most of our data came from our Recipes and Foods table, we didn't have a lot to work with in the NutritionLog other than the mock data Jake put together. This sparseness of the data made it hard to test the visualization (since it was made to give users a good idea of their nutrition during the week), so I had to make more data to compensate. What I learned was to make sure we had data ready (even if it was mock data, which especially made sense in this situation for testing).

## Other Things, Future Work, and Labor Division
Not much else changed from our proposal to the final product besides what we listed above. Future work that can be done other than the interface includes coding up the other things from our proposal that we wanted to do (such as the individual calorie requirement) and simply finding/creating more data. Our application was based in data, so not having data to work with throughout the process made it difficult to understand exactly what was going on as we connected and developed the front and backend. 

Our division of labor was fair throughout the entire semester. In stage 0, Jake did the setup, which made us decide to make him the captain. In stage 1, Jake worked with the team to divide the work equally, which worked out well. In stage 2, we again split up the work equally except for the UML design, which we did entirely together in class with the help of Aryan. Stage 3 was again split up equally with Chi unfortunately having to deal with messy data, which we all helped with. Then in stage 4, Jason led the setup, Dan did the visualization, and we all again split up the work from there. Our teamwork was good, as we frequently communicated over our text group chat and met in-person and online a few times throughout the semester for planning and splitting up the work. Throughout the semester, we had no issues with each other and no one interfered with anyone else's work. 

- Project Video: 
TODO
